# INDEX

[TOC]



1. [상속](#상속)
2. [생성자 호출 순서, 소멸자 호출 순서](#생성자-호출-순서-소멸자-호출-순서)
3. [다형성](#다형성)
4. [다형성 정적 바인딩](#다형성-정적-바인딩)
5. [다형성 동적 바인딩](#다형성-동적-바인딩)
6. [다형성 가상 소멸자](#다형성-가상-소멸자)
7. [다중 상속](#다중-상속) 

## 상속

#### 상속이란?

* 다른 클래스의 특성들을 내려받음
  * 베이스 클래스(부모 클래스)
  * 파생 클래스(자식 클래스)
* 파생 클래스의 개체는 다음 것들을 가짐
  * 베이스 클래스의 멤버 변수
  * 베이스 클래스의 멤버 메서드
  * 자신의 생성자와 소멸자
* 파생클래스는 멤버변수 및 메서드 추가가능



​	**파생 클래스의 접근 제어자**

* Java와 달리 상속 시 베이스 클래스의 메버의 접근수준을 결정할 수 있다
  * public 상속
    * 그대로 가져옴
  * protected 상속
    * public -> protected로 변경
  * private 상속
    * public/protected -> private로 변경

	**예시**
>
>```cpp
>//Animal.h
>class Animal
>{
>public:
>        Animal(int age);
>private:
>        int mAge;
>};
>
>//Cat.h
>class Cat : public Animal
>{
>public:
>        Cat(int age, const char* name);
>private:
>        char* mName;
>};
>
>//Cat.cpp
>Cat::cat(int age, const char* name)
>        :Animal(age)
>{
>        size_t size = strlen(name) +1;
>        mName = new char[size];
>        strcpy(mName, name);
>}
>```



## 생성자 호출 순서, 소멸자 호출 순서

#### 생성자 호출 순서

* 부모 생성자 -> 자식 생성자

* 베이스 클래스의 생성자가 먼저 호출됨
  
  * 명시적 또는 암시적으로
  
* 그 다음 파생 클래스의 생성자가 호출됨

* 부모 클래스의 특정 생성자를 호출할 때는 초기화 리스트를 사용해야 함

* **유의사항** : 암시적으로 부모 클래스를 호출할 때, 없으면 문제가 생길 수 있음 

  >```cpp
  >//Animal.h
  >class Animal
  >{
  >public:
  >	Animal(int age);
  >private:
  >	int mAge;
  >}
  >//Cat.cpp
  >Cat::cat(int age, const char* name)
  >	:Animal(age)
  >//암시적으로 Animal()을 호출
  >//하지만 Animal()이 없음 -> 컴파일에러!!!!
  >{
  >       size_t size = strlen(name) +1;
  >       mName = new char[size];
  >       strcpy(mName, name);
  >}
  >```



#### 소멸자 호출 순서

* 자식 소멸자 -> 부모 소멸자
* 생성자 호출순서와 정반대
* 파생클래스 소멸자의 마지막에서 베이스 클래스의 소멸자가 자동적으로 호출됨



## 다형성



## 다형성 정적 바인딩



## 다형성 동적 바인딩



## 다형성 가상 소멸자



## 다중 상속



## 추상 클래스



## 인터페이스