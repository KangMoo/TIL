# 생성패턴

## 싱글톤(Singleton) 패턴

- 인터페이스를 오직 한개만 제공하는 클래스
- 시스템 런타임, 환경 세팅에 대한 정보 등, 인스턴스가 여러개일 때 문제가 생길 수 있는 경우에 인스턴스를 오직 한개만 만들어 제공하는 클래스가 필요할 때 사용

![](./images/01_01.png)

### 구현방법 1

- private 생성자에 static 메서드를 사용한다
  - priavte 생성자를 사용함으로써 다른 클래스에서 인스턴스 생성을 방지한다
  - 객체를 얻을 때는 `getInstance()` 메서드를 사용한다

```java
public class Settings {
    private static Settings instance;

    private Settings() {}

    public static Settings getInstance() {
        if (instance == null) {
            instance = new Settings();
        }
        return instance;
    }
}
```

- 이 싱글톤 구현방법은 멀티 스레드환경에서 안전하지 않다

### 구현방법 2

- 동기화(synchronized)를 사용해 멀티쓰레드 환경에 안전하게 만드는 방법

```java
public class Settings {
    private static Settings instance;

    private Settings() {}

    public static synchronized Settings getInstance() {
        if (instance == null) {
            instance = new Settings();
        }
        return instance;
    }
}
```

- 이 싱글톤 구현 방법은 getInstnace 메서드 호출시마다 동기화 과정이 추가되기 때문에 성능의 저하가 생긴다

### 구현방법 3

- 이른 초기화를 사용하는 방법

```java
public class Settings {
    private static final Settings INSTANCE = new Settings();
    private Settings() {}
    public static Settings getInstance() {
        return INSTANCE;
    }
}
```

- 이 싱글톤 구현 방법은 사용하지 않을 수도 있는 인스턴스까지 미리 생성해버린다
  - 이 인스턴스를 만드는 비용이 클 경우 만약 이 인스턴스를 사용하지 않는다면 생성하는 것 자체가 낭비가 될 수 있다

### 구현방법 4

- double checked locking으로 효율적인 동기화 블럭 만들기

```java
public class Settings {
    private static volatile Settings INSTANCE = new Settings();
    private Settings() {}
    public static Settings getInstance() {
        if (INSTANCE == null) {
            synchronized (Settings.class) {
                if (INSTANCE == null) {
                    INSTANCE = new Settings();
                }
            }
        }
        return INSTANCE;
    }
}
```
> `volatile` 키워드를 사용해서 구현해야 한다

- 이 싱글톤 구현 방법은 이해하기 복잡할 수 있다
  - `volatile` 키워드를 왜 사용하는지 이해하는 과정이 필요하다
- `volatile` 키워드를 사용하지 않는 자바 버전 (1.5 미만의 버전)에서는 사용할 수 없다

### 구현방법 5

- static inner 클래스를 사용하는 방법 (권장방법)

```java
public class Settings {
    private static volatile Settings INSTANCE = new Settings();

    private Settings() { }

    private static class SettingsHolder {
        private static final Settings SETTINGS = new Settings();
    }

    public static Settings getInstance() {
        return SettingsHolder.SETTINGS;
    }
}
```

- INSTANCE가 `static final`로 선언되어 있지만 해당 변수가 선언된 `SettingHolder` 클래스는 `getInstance()` 함수가 호출될 때 로딩되기 때문에 지연 초기화로 볼 수 있다

> 구현방법 1~5의 공통적인 단점 : **특정 방법으로 싱글톤 구현을 깨뜨릴 수 있다**
> 1. 리플렉션을 사용하는 경우
> 2. 직렬화 & 역직렬화를 사용하는 경우
>   - 직렬화&역직렬화는 `readResolve`메서드를 재정의하는것을 통해 해결이 가능하다

### 구현방법 6

- enum 사용방법
  - enum은 새 인스턴스 생성이 불가능하다
  - 리플렉션, 직렬화&역직렬화를 통한 싱글턴 우회방법을 막을 수 있다

```java
public enum Settings {
    INSTANCE;
}
```

- 이 싱글톤 구현 방법은 사용하지 않을 수도 있는 인스턴스까지 미리 생성해버린다
  - 이 인스턴스를 만드는 비용이 클 경우 만약 이 인스턴스를 사용하지 않는다면 생성하는 것 자체가 낭비가 될 수 있다
- enum을 사용하기 때문에 상속을 사용할 수 없다