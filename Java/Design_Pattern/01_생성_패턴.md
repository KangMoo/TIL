# 생성패턴

## 싱글톤(Singleton) 패턴

- 인터페이스를 오직 한개만 제공하는 클래스
- 시스템 런타임, 환경 세팅에 대한 정보 등, 인스턴스가 여러개일 때 문제가 생길 수 있는 경우에 인스턴스를 오직 한개만 만들어 제공하는 클래스가 필요할 때 사용

![](./images/01_01.png)

### 구현방법 1

- private 생성자에 static 메서드를 사용한다
  - priavte 생성자를 사용함으로써 다른 클래스에서 인스턴스 생성을 방지한다
  - 객체를 얻을 때는 `getInstance()` 메서드를 사용한다

```java
public class Settings {
    private static Settings instance;

    private Settings() {}

    public static Settings getInstance() {
        if (instance == null) {
            instance = new Settings();
        }
        return instance;
    }
}
```

- 이 싱글톤 구현방법은 멀티 스레드환경에서 안전하지 않다

### 구현방법 2

- 동기화(synchronized)를 사용해 멀티쓰레드 환경에 안전하게 만드는 방법

```java
public class Settings {
    private static Settings instance;

    private Settings() {}

    public static synchronized Settings getInstance() {
        if (instance == null) {
            instance = new Settings();
        }
        return instance;
    }
}
```

- 이 싱글톤 구현 방법은 getInstnace 메서드 호출시마다 동기화 과정이 추가되기 때문에 성능의 저하가 생긴다

### 구현방법 3

- 이른 초기화를 사용하는 방법

```java
public class Settings {
    private static final Settings INSTANCE = new Settings();
    private Settings() {}
    public static Settings getInstance() {
        return INSTANCE;
    }
}
```

- 이 싱글톤 구현 방법은 사용하지 않을 수도 있는 인스턴스까지 미리 생성해버린다
  - 이 인스턴스를 만드는 비용이 클 경우 만약 이 인스턴스를 사용하지 않는다면 생성하는 것 자체가 낭비가 될 수 있다

### 구현방법 4

- double checked locking으로 효율적인 동기화 블럭 만들기

```java
public class Settings {
    private static volatile Settings INSTANCE = new Settings();
    private Settings() {}
    public static Settings getInstance() {
        if (INSTANCE == null) {
            synchronized (Settings.class) {
                if (INSTANCE == null) {
                    INSTANCE = new Settings();
                }
            }
        }
        return INSTANCE;
    }
}
```
> `volatile` 키워드를 사용해서 구현해야 한다

- 이 싱글톤 구현 방법은 이해하기 복잡할 수 있다
  - `volatile` 키워드를 왜 사용하는지 이해하는 과정이 필요하다
- `volatile` 키워드를 사용하지 않는 자바 버전 (1.5 미만의 버전)에서는 사용할 수 없다

### 구현방법 5

- static inner 클래스를 사용하는 방법 (권장방법)

```java
public class Settings {
    private static volatile Settings INSTANCE = new Settings();

    private Settings() { }

    private static class SettingsHolder {
        private static final Settings SETTINGS = new Settings();
    }

    public static Settings getInstance() {
        return SettingsHolder.SETTINGS;
    }
}
```

- INSTANCE가 `static final`로 선언되어 있지만 해당 변수가 선언된 `SettingHolder` 클래스는 `getInstance()` 함수가 호출될 때 로딩되기 때문에 지연 초기화로 볼 수 있다

> 구현방법 1~5의 공통적인 단점 : **특정 방법으로 싱글톤 구현을 깨뜨릴 수 있다**
> 1. 리플렉션을 사용하는 경우
> 2. 직렬화 & 역직렬화를 사용하는 경우
>   - 직렬화&역직렬화는 `readResolve`메서드를 재정의하는것을 통해 해결이 가능하다

### 구현방법 6

- enum 사용방법
  - enum은 새 인스턴스 생성이 불가능하다
  - 리플렉션, 직렬화&역직렬화를 통한 싱글턴 우회방법을 막을 수 있다

```java
public enum Settings {
    INSTANCE;
}
```

- 이 싱글톤 구현 방법은 사용하지 않을 수도 있는 인스턴스까지 미리 생성해버린다
  - 이 인스턴스를 만드는 비용이 클 경우 만약 이 인스턴스를 사용하지 않는다면 생성하는 것 자체가 낭비가 될 수 있다
- enum을 사용하기 때문에 상속을 사용할 수 없다

---

## 팩토리 패턴

- 구체적으로 어떤 인스턴스를 만들지는 서브 클래스가 만들게 정하는 패턴
- 다양한 구현체(Producet)가 있고, 그중에서 특정한 구현체를 만들 수 있는 다양한 팩토리(Creator)를 제공할 수 있다
- 확장에 열려있고 변경에 닫혀있는 구조를 만들 수 있다
  - 기존 코드 변경 없이 인터페이스를 구현하는 새로운 클래스를 작성하여 새로운 기능 추가가 가능하다
- 장점 : if문이나 switch문으로 분기처리하던 로직을 작성했던 것을 클라이언트에서 원하는 방식을 선택하게 하여 분기처리 없이 로직 추가가 가능하다
- 단점 : 새로운 로직이 추가될 때마다 클래스를 추가해야 한다
- 


![](./images/01_02.png)

### 예시

![](./images/01_03.png)

```java
public interface ShipFactory {

    default Ship orderShip(String name, String email) {
        validate(name, email);
        prepareFor(name);
        Ship ship = createShip();
        sendEmailTo(email, ship);
        return ship;
    }

    void sendEmailTo(String email, Ship ship);

    Ship createShip();

    private void validate(String name, String email) {
        if (name == null || name.isBlank()) {
            throw new IllegalArgumentException("배 이름을 지어주세요.");
        }
        if (email == null || email.isBlank()) {
            throw new IllegalArgumentException("연락처를 남겨주세요.");
        }
    }

    private void prepareFor(String name) {
        System.out.println(name + " 만들 준비 중");
    }
}
```

```java
public abstract class DefaultShipFactory implements ShipFactory {
    @Override
    public void sendEmailTo(String email, Ship ship) {
        System.out.println(ship.getName() + " 다 만들었습니다.");
    }
}

public class BlackShipFactory extends DefaultShipFactory {
    @Override
    public Ship createShip() {
        return new Blackship();
    }
}

public class WhiteShipFactory extends DefaultShipFactory {
    @Override
    public Ship createShip() {
        return new Whiteship();
    }
}
```



## 추상 팩토리 패턴

- 서로 관련있는 여러 객체를 만들어주는 인터페이스
- 구체적으로 어떤 클래스의 인터페이스(concrete product)를 사용하는지 감출 수 있다
- 클라이언트 코드에서 구체적인 클래스의 의존성을 제거하여 구현 가능하다

![](./images/01_04.png)

### 예시

![](./images/01_05.png)
```java
public interface ShipPartsFactory {

    Anchor createAnchor();

    Wheel createWheel();

}

public interface Anchor {
}

public interface Wheel {
}
public class WhiteShipFactory extends DefaultShipFactory {

    private final ShipPartsFactory shipPartsFactory;

    public WhiteShipFactory(ShipPartsFactory shipPartsFactory) {
        this.shipPartsFactory = shipPartsFactory;
    }

    @Override
    public Ship createShip() {
        Ship ship = new Whiteship();
        ship.setAnchor(shipPartsFactory.createAnchor());
        ship.setWheel(shipPartsFactory.createWheel());
        return ship;
    }
}
```

```java
public class WhiteAnchorPro implements Anchor{
}

public class WhiteWheelPro implements Wheel {
}
```

```java
public class WhiteAnchor implements Anchor {
}

public class WhiteWheel implements Wheel {
}
public class ShipInventory {

    public static void main(String[] args) {
        ShipFactory shipFactory = new WhiteShipFactory(new WhiteShipPartsFactory());
        Ship ship = shipFactory.createShip();
        System.out.println(ship.getAnchor().getClass());
        System.out.println(ship.getWheel().getClass());
    }
}

```

> 팩토리 패턴 vs 추상 팩토리 패턴
> - 팩토리 패턴
>   - 팩토리를 구현하는 방법에 초점을 둔다 (상속)
>   - 구체적인 객체 생성 과정을 하위 또는 구체적인 클래스로 옮기는 것이 목적
> - 추상 팩토리 패턴
>   - 팩토리를 사용하는 방법에 초첨을 둔다 (컴포지션)
>   - 관련있는 여러 객체를 구체적인 클래스에 의존하지 않고 만들 수 있게 해주는 것이 목적
