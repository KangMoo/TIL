### 함수 정의

자바나 C#과 달리 루비에서는 함수를 정의하기 위해서 클래스를 따로 정의할 필요가 없다. 그냥 콘솔 위에서 함수를 정의할 수도 있다.

```ruby
>> def tell_the_truth
>>   true
>> end
```

모든 함수는 어떤 값을 리턴한다. 명시적인 값을 설정하지 않으면 함수 안에 존재하는 마지막 표현이 나타내는 값이 자동적으로 리턴된다. 다른 모든 존재와 마찬가지로 이러한 함수 역시 루비에서는 하나의 객체다.



### 배열

배열능 루비에서 많은 역할을 담당하는 순차적 커렉션이다. 루비에서 가장 핵심적인 순차적 컬렉션은 배열이라고 할 수 있다.

```ruby
>> animals = ['lions', 'tigers', 'bears']
=> ["lions", "tigers", "bears"]
>> puts animals
lions
tigers
bears
=> nil
>> animals[0]
=> "lions"
>> animals[2]
=> "bears"
>> animals[-1]
=> "bears"
>> animals[2]
=> "bears"
>> animals[0...1]
=> ["lions"]
>> (0..1).class
=> Range
```

루비의 컬렉션이 상당히 자유롭다는 것을 위의 코드에서 확인할 수 있다. 정의되지 않은 배열 요소에 접근하면 루비는 에러를 발생시키는 대신 단순히 `nil`을 리턴한다. 배열을 더 강력하게 만들어 주지는 않지만 사용하기 더 쉽게 만들어주는 기능도 확인할 수 있다. `animals[-1]`은 뒤에서 첫번째 요소를 리턴하고, `animals[-2]`는 뒤에서 두번째ㅑ 요소를 리턴한다. `animals[0..1]`이라는 표현은 단숳니 문법적 설탕처럼 보이지만 그 이상이다. `0..1`은 사실 0부터 1까지의 Range라는 객체를 의미한다.

만약 하나의 배열이 되기 전에 사용한 경우 아래와 같은 결과를 확인할 수 있다.

```ruby
>> a[0] = 0
NameError (undefined local variable or method `a' for main:Object)
>> a=[]
=> []
```

위의 에러 메시지는 루비가 배열과 해시를 다루는 방식에 대한 힌트를 제공한다. `[]`라는 표현은 사실 `Array`라는 객체에 정의된 메서드의 이름이다

```ruby
>> [1].class
=> Array
>> [1].methods.include?('[]')
=> false
```

그러므로 `[]`과 `[]=`는 배열에 접근하기 위해 제공되는 문법적 설탕에 해당한다. 이러한 문법을 제대로 이용하려면 먼저 빈 배열을 만들고, 그다음에야 배열을 사용할 수 있다.