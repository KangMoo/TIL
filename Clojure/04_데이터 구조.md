### 불리언(Boolean)

참과 거짓 값을 표현하는 데이터 구조다. 참 값은 true, 거짓 값은 false로 표현한다.

```clojure
user=> true
true
user=> false
false
```

true인지 false인지 확인해주는 함수도 있다.

```clojure
user=> (true? true)
true
user=> (false? false)
true
```



### nil

널 값으로 아무 값도 없는 값을 말한다.

```clojure
user=> nil
nil
```

역시 `nil`인지 확인해주는 `nil?`함수가 있다.

```clojure
user=> (nil? nil)
true
user=> (nil? false)
false
```



### 숫자 (Number)

숫자는 1, 2, 3, ... 와 같이 그냥 숫자이고, 0.5, 1.5 같은 소수점도 있다. 숫자는 내부적으로 자바의 Long에 저장되고 소수는 Double에 저장된다.

```clojure
user=> 1
1
user=> 0.5
0.5
```

Ratio라는 분수 타입이 있는데 `1/3` 과 같이 표현한다.

```clojure
user=> 1/3
1/3
```

사칙 연산 함수들을 제공하고 함수명은 각각 `+`, `-`, `*`, `/`이다.

함수는 `(함수명 파라미터값 파라미터값 파라미터값 ...)` 형태로 실행한다.

```clojure
user=> (+ 1 2)
3
user=> (- 2 1)
1
user=> (- 1 2)
-1
user=> (* 2 3)
6
user=> (/ 10 2)
5
user=> (/ 1 3)
1/3
```

사칙 연산 합수는 인자를 여러개 가질 수 있다.

```clojure
user=> (+ 1 2 3 4 5)
15
```

값이 같은지 비교하는 `=` 함수도 있다.

```clojure
user=> (= 1 1)
true
user=> (= 1 1.5)
false
```



### 문자(Character)

단일 문자로 `\문자` 형태로 사용한다.

```clojure
user=> \a
\a
```

UTF-8을 지원하기 때문에 한글도 사용할 수 있다.

```clojure
user=>\가
\가
```



### 문자열(String)

문자열은 `"`로 감싸서 표현한다.

```clojure
user=> "clojure"
"clojure"
```

다양한 문자열 함수들을 제공한다.

```clojure
user=> (str "Hello" " " "World")
"Hello World"
user=> (format "Hello %s" "World")
"Hello World"
user=> (count "Hello")
5
```

문자열 비교도 `=`함수로 하면 된다.

```clojure
user=> (= "clojure" "clojure")
true
user=> (= "clojure" "eunmin")
false
```

자바와 같이 static 문자열은 문자열 테이블에 있는 객체를 사용한다.

따라서 `=`가 제대로 비교 되는지 아래와 같이 확인해 봐야한다.

```clojure
user=> (= "abc" (str "a" "b" "c"))
true
user=> (identical? "abc" (str "a" "b" "c"))
false
user=> (identical? "abc" "abc")
true
```

확인해 본 결과 값이 같은지 비교할 때 `=`를 써도 된다는 것을 알 수 있다.

실제로 `=`비교는 내부적으로 자바의 `equals`로 비교하기 때문에 문자열 값 비교가 정상적으로 동작한다.

> `identical?` 은 자바의 `==`와 같다고 생각하면 된다.

### 리스트(List)

순서가 있는 값으 목록으로 `(항목 항목 항목)` 형태로 표현한다.

```clojure
user=> (0 1 2 3 4)
ClassCastException java.lang.Long cannot be cast to clojure.lang.IFn  user/eval17466 (form-init2102152485734565748.clj:1)
```

위의 리스트는 0부터 4까지 값을 순서대로 갖는 자료구조이다.

REPL에서 코드를 입력하고 엔터를 치면 에러가 난다. REPL은 엔터를 치면 클로저 코드를 평가해 값을 계산하는데 리스트 자료구조는 코드가 평가(실행 또는 값을 구함)될 때 함수로 동작하기 때문이다.

그래서 위의 예제는 `0`이라는 이름의 함수에 `1`, `2`, `3`, `4` 를 인자로 넘기는 코드로 동작하고 `0` 이라는 함수가 없기 때문에 에러가 난 것이다.

어떤 값이 평가되는 것을 막기 위해 앞에 `'`를 붙이면 된다. 값이 평가되지 않으면 값 그 자체로 사용된다.

```clojure
user=> '(0 1 2 3 4)
(0 1 2 3 4)
user=> '(0 1 2)
(0 1 2)
user=> '("클로저" "데이터" "형식")
("클로저" "데이터" "형식")
```

다양한 리스트 함수가 있다.

```clojure
user=> (first '(0 1 2))
0
user=> (second '(0 1 2))
1
user=> (last '(0 1 2))
2
user=> (rest '(0 1 2))
(1 2)
user=> (count '(0 1 2))
3
```



### 벡터(Vector)

리스트 처럼 순서 있는 항목으로 `[항목 항목 항목]` 형태로 표현한다.

리스트는 첫번째 항목이 함수로 실행돼서 데이터로 사용하기 때문에 주로 데이터를 담을 때 벡터를 쓴다.

벡터에도 리스트 함수를 쓸 수 있다.

```clojure
user=> [0 1 2]
[0 1 2]
```