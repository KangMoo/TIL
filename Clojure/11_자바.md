## 자바

클로저는 JVM안에서 동작하는 언어이기 때문에 자연스럽게 자바를 사용할 수 있다. 따라서 기존 자바 라이브러리를 모두 사용할 수 있다.

물로 ㄴ자바스크립트로 변환이되는 클로저스크립트는 다르다. 클로저스크립트는 대신 자바스크립트 라이브러리들을 사용할 수 있다.

클로저에서 자바를 사용한다는 말은 다음과 같다.

- 자바의 클래스를 사용
- 자바의 클래스를 생성

또한 자바에서 클로저를 사용할 수 있다



## 클로저에서 자바 클래스 사용하기

### 자바 인스턴스 생성하기

`new` 구문으로 클로저에서 자바 인스턴스로 생성할 수 있다.

```bash
user=> (new java.util.Random)
#object[java.util.Random 0x380a1372 "java.util.Random@380a1372"]
```

더 간결하고 자주 사용되는 특별한 문법이 있는데 자바 클래스명 뒤에 `.`을 붙여 생성하는 방법이다

```bash
user=> (java.util.Random.)
#object[java.util.Random 0x3fa8678e "java.util.Random@3fa8678e"]
```

기본 생성자 말고 다른 생성자로 인스턴스를 생성하려면 `.` 구문 뒤에 생성자 인자를 넣으면 된다

```bash
user=> (def seed 1000)
#'user/seed
user=> (java.util.Random. seed)
#object[java.util.Random 0x21f8c591 "java.util.Random@21f8c591"]
```



## 자바 메서드 호출하기

생성된 인스턴스의 메서드를 호출하려면 `(.메서드명 인스턴스)` 형태로 사용한다.

```bash
user=> (def random (java.util.Random.))
#'user/random
user=> (.nextInt random)
682185547
```

메서드의 인자는 인스턴스 다음으로 순서대로 넣어준다

```bash
user=> (.nextInt random 10)
5
```

`.`구문과 메서드명을 띄어서 사용할 수도 있지만 잘 사용되지 않는다



## 인스턴스 상태

클로저의 기본 데이터들은 상태를 가지지 않는다고 설명했다. 값을 설정하면 기존 값은 변하지 않고 변경된 값을 가지는 새로운 값이 리턴되는 식이다. 그럼 자바 인스턴스도 그렇게 동작할까? 그렇지 않다. 자바 인스턴스는 인스턴스를 직접 접근하기 때문에 상태를 가진다

```bash
user=> (def date (java.util.Date. 0))
#'user/date
user=> date
date
#inst "1970-01-01T00:00:00.000-00:00"
```

`java.util.Date` 생성자에 0을 주고 `epoch` 시간 0를 생성했다. `Date` 클래스의 `setTime` 메서드로 10초가 지난 시간으로 변경하고 확인해보자.

```bash
user=> (.setTime date 10)
nil
user=> date
#inst "1970-01-01T00:00:00.010-00:00"
```

확인해보니 10초가 지난 `epoch` 시간을 가지고 있는 것을 알 수 있다. 결국 기존 `date` 인스턴스의 내부 값이 변경된 것이다.



## static 메서드 호출하기

자바의 static 메서드는 인스턴스를 생성하지 않고 호출하기 때문에 사용 방법이 조금 다르다

```bash
user=> (System/currentTimeMillis)
1428242247005
```



## static 필드 사용하기

static 필드도 static 메서드와 비슷하지만 함수 호출이 아닌 값 형식으로 사용한다.

```bash
user=> java.lang.Long/MAX_VALUE
9223372036854775807
```

