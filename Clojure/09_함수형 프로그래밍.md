## 함수형 프로그래밍

함수형 프로그래밍은 프로그래밍 패러다임 중 하나다.

클로저는 함수형 프로그래밍을 기반으로 하고 있다.

시간이 흐름과 조건에 따라 상태를 바꿔 결과를 내는 명령형 패러다임과는 다르게 함수의 조합으로 결과를 표현하는 방식이다.

실제로 함수 조합은 단순하고 확장성이 뛰어나기 때문에 특별한 규칙없이 함수 조합만으로 숫자를 표현하거나 사칙 연산을 하거나 분기문, 반복문등을 표현할 수 있다.

하지만 함수형 프로그래미 언어들은 연산 함수, 분기 처리, 함수 재귀등을 제공하기 때문에 람다 계산법을 이해하지 못해도 쉽게 프로그래밍을 작성할 수 있다

그래도 함수형 프로그래밍을 잘 하려면 람다 계산법과 함수형 푸로그래밍의 많은 기법들을 익혀야 복잡한 프로그래밍을 더 잘 표현할 수 있다.

이 글은 클로저를 처음 접하는사람들을 위한 글이기 때문에 함수형 프로그래밍 기법을 다루지 않고 명령형 프로그래밍에서 익숙한 상태 변경과 반복문을 함수형 프로그래밍에서 어떤 식으로 표현하는지 알아본다.

함수현 프로그래밍을 알고 싶다면 먼저 람다 계산법을 익힌 후 SICP 책과 하스켈 언어와 같은 것을 공부하면 도움이 될 것 같다.



## 변경 불가능한 데이터

함수형 프로그래밍에서는 상태의 개념이 없기 때문에 클로저는 값을 변경할 수 없다.

```clojure
user=> (def user {:id 1 :name "eunmin" :level 10})
#'user/user
user=> (update-in user [:level] inc)
{:name "eunmin", :level 11, :id 1}
user=> user
{:name "eunmin", :level 10, :id 1}
user=> (update-in user [:level] inc)
{:name "eunmin", :level 11, :id 1}
user=> (update-in user [:level] inc)
{:name "eunmin", :level 11, :id 1}
```

위의 예제는 `user`라는 이름에 바인딩된 맵에 `:level`값을 1 증가시키는 예제다.

`update-in`함수는 첫번째 파라미터로 맵을, 두번째 파라미터로 변경할 값을 가지는 키 벡터를, 세번째 파라미터로 변경할 값을 리턴하는 함수를 받는다.

마지막 파라미터는 하나의 파라미터를 가지는 함수인데 원래 값이 인자로 넘어온다.

`udpate-in` 함수로 맵에 있는 값을 변경했지만 변경된 새로운 맵을 리턴하고 원래 `user`값은 그대로 있다.

클로저의 변경 함수들은 기존 값을 변경하지 않고 새로운 값을 리턴한다

크기가 큰 리스트 값의 일부가 바뀌어도 새로운 값이 리턴된다면 메모리 낭비가 우려될 것이다.

하비나 클로저는 내부적으로 변경되지 않은 원래 값을 참조하도록 설계되어 있어 걱정하지 않아도 된다.