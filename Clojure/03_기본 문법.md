## 클로저 시작하기

### 클로저 코드의 특징

컴퓨터 언어의 역사에서 Lisp 계얼 언어들은 Algol 계열 언어들과는 다른 계보를 형셩해왔다. 오늘날의 주류 언어들 (C, C++, C#, Java, JavaScript, Python, Ruby, Perl ... ) 은 모두 알골계 언어들인데 반해 클로저는 리슾 계열 언어여서 실제 코드를 본 후 아마도 생소한 느낌을 갖는 사람들이 많을 것이다. 따라서 클로저 언어를 본격적으로 익히기에 앞서 다른 언어들과의 두드러진 차이점부터 확인해본다.



### 괄호의 사용

클로저 코드를 처음 접한 사람들은 아마도 많은 괄호에 강한 거부감을 느꼈을 것이다. 그런 느낌은 이 글을 쓰고 있는 필자들의 경우도 예외는 아니었다. 하지만 그 형태가 아니라, 괄호가 있음으로 인해 가지게 되는 막강항 효용에 눈뜨기 시작할 때부터, 거부감의 대상이었던 그 괄호들이 아름답게 보이기 시작한다. 이것은 단순한 주관적인 느낌이 아니라, 리습 언어를 알아가는 사람들의 공통된 심리적 패턴이다.



괄호가 있어서 얻을 수 있는 첫 번째 이점은, 코드의 의미가 명확해져 연산자 우선 순위를 따로 외울 필요가 없나는 점이다. 다음 두 코드를 보면 어느 것의 의미가 명확한지는 자명하다.

C

```c
a > b + c * d && e
```

Clojure

```clojure
(and (> a (+ b (* c d))) e)
```

하지만 괄호를 사용하는 진정한 위력은 매크로를 작성할 때 나온다. 리습 언어가 Programmable Programming Language라고 불리는 이유는 매크로를 통해 코드를 조작할 수 있기 때문인데, 이 괄호가 있음으로 코드 조작이 수월해진다. 위의 클로저 코드를 잘 살펴보면 이미 코드 형태 자체가 구문 트리 (Syntax Tree)의 형식이어서, 이 코드를 변형하기 위해 별도의 파싱(parsing)과정을 거칠 필요가 없기 때문이다. 지금 당장은 이해가 안되더라도 매크로를 작성하다 보면 그 가치를 깨닫게 된다. 그리고 바로 그 순간부터 괄호가 아름답게 보이기 시작한다. 사실 괄호가 있음으로 인해 좀 더 강력하면서도 간결한 프로그래밍이 가능해진다면, 괄호가 많다는 것이 무슨 그리 큰 대수이겠는가?

### 전위 표기법

리습 언어들에서는 연산자와 함수명이 괄호 내의 맨 앞 자리에 온다. 사실 함수명의 경우에는 C 언어나 클로저나 큰 차이가 없다. 단지 함수 이름이 괄호 밖에 있는가 안에 있는가의 차이와, 함수의 인수들 사이에 콤마를 찍느냐 마느냐의 차이밖에는 없다. 함수명의 경우에는, 약간의 차이만 있을 뿐 C언어도 이미 전위 표기법을 사요하고 있다는 말이다.

C

```c
printf("ASCII value = %d, Character = %c\n", ch , ch);
```

Clojure

```clojure
(printf "ASCII value = %d, Character = %c%n" ch ch)
```

차이가 있다면 연사자의 경우인데, C언어에서는 중위표기법을 사용하고 클로저에서는 함수명과 마찬가지로 전위 표기법을 사용한다

C

```c
a + b + c + d + e;
```

Clojure

```clojure
(+ a b c d e)
```

클로저의 경우에는 전위 표기법을 사용함으로써, 연산항이 많을 때 `+` 기호를 반복할 필요가 없다는 장점이 있따.

리습 계열 언어에서는 연산자와 함수가 다른 취급을 받지 않는다. 연산자의 경우, 수학에서 이미 중위 표기법을 사용하고 있어 대부분의 언어가 그것을 답습하고 있을 뿐, 프로그래밍에서는 굳이 그것을 구분해 처리하지 않는 것이 오히려 일관되고 편리하다. 연산자가 중간에 위치갛게 되면 컴파일러에서는 이를 따로 파싱해야하는 수고를 한 번 더 거쳐야 하기 때문이다.

예를 들어 C언어에서 `**`연산자를 거듭제곱 연산자로 여러분이 언어체 추가하고 싶다고 가정해보자. 그러자면 우선 C표준을 다루는 위원회에 제안을 해야 할 것이다. 물론 이 제안이 받아들여진다는 보장도 없지만, 이 위원회가 그 타당성을 인정해 새로운 C언어 표준에 반영하기로 했다고 가정해보자. 그러면 그 후에 모든 C 컴파일러를 이 새로운 표준에 맞춰 다시 작성해야 할 것이고, 이 연산자를 이용해 작성한 C소스는 구 버전의 컴파일러에서는 제대로 컴파일 되지도 않을 것이다. 이 상황을 클로저에 적용해 보면 일은 너무도 간단해진다. 클로저 프로그래머는 다음과 같이 코드를 작성하면 된다.

```clojure
(defn ** [a b]
  (Math/pow a b))

(** 2 8)   ; => 256.0
```