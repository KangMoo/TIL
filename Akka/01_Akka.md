## 아카란

- 튼튼하고 회복성 있는 실시간 트랜잭션 분산 프로세싱
- Actor모델을 활용해 고수준의 추상화와 확장이 가능하면서도 탄력적이며 반응형의 어플리케이션을 구축하기 위한 기반을 제공한다
- 동시성과 내고장성을 가지면서 확장성있는 분산 구조의 어플리케이션 구현을 목표로 한다.



## Actor 모델이란

- 40년 전에 소개됐으나 당시에는 구현이 힘들어 제대로 된 가치를 인정받지 못하고 최그네 와서야 주목받은 프로그래밍 모델
- 전통적인 객체지향 프로그래밍 모델로 완벽히 해결하기 어려웠던 분산 시스템 구축에 필요한 난제를 해결할 방법으로 주목받게 되었다
- 액터 모델이 중요하게 다루는 사항은 세가지가 있다
  - 캡슐화의 문제
  - 현대 컴퓨터 아키텍처 상의 공유 메모리에 대한 착각
  - 콜스택에 대한 착각



### 캡슐화의 문제

객제지향 프로그래밍의 핵심 골격은 캡슐화이다.

캡슐화는 객체 내부 데이터는 외부에서 직접 접근할 수 없으며 허용된 메서드를 통해 호출해야만 변경할 수 있도록 강제하여 내부 데이터를 보호하도록 한다.

하지만 두개 이상의 스레드에서 하나의 오브젝트의 메서드를 동시에 호출하는 경우 예상치 못한 결과를 발생시킬 수 있다. 그리고 이런 문제를 해결하기 위해서 메서드에 락(lock)을 건다.

하지만 락(lock)은 아주 비싼 비용의 해결책이다

- 락은 동시성에 심각한 제약을 가한다. OS상에서 스레드를 일시 중지했다가 복구해야 하기 때문이다.
- 호출하는 스레드가 블록킹되고 다른작업을 할 수 없게 된다.
- 데드락이라는 새로운 위험 요소를 만들어 낼 수 있다.

정리하자면

- 객체는 단일 스레드 상황에서만 캡슐화를 보장할 수 있으며, 다중 스레드 상황에서는 캡슐화 보장이 되지 않는다.
- 락을 통해 캡슐화를 유지할 수 있지만, 락은 비용이 매우 비싸고, 데드락이라는 치명적인 문제가 발생할 가능성이 존재한다.
- 락은 로컬에서만 동작하며 분산 락이 있긴 하지만 수평 규모 확장에서는 제약이 존재한다.



### 현대 컴퓨터 아키텍처상에서 공유 메모리에 대한 착각

80-90년대의 프로그래밍 모델에서는변수에 값을 할당하는 작업은 메모리의 특정 위치에 직접 값을 쓰는 것을 개념화한 것이다. 현대의 아키텍처에서는 (단순화하면) CPU는 메모리에 직접 값을 쓰지 않고 캐시 라인에 쓴다. 캐시 라인은 CPU 코어의 로컬 영역에 해당하며, 어떤 코어가 쓴 내용이 다른 코어에서는 볼 수 없다. 이릉 위해서 로컬 변경사항을 다른 코어에서 보려면 캐시 라인의 내용을 옮겨가는 작업이 필요하다

JVM에서는 스레드들간에 공유되어야 하는 메모리의 위치를 명시적으로 표시하기 위해서 `volatile` 이나 `Atomic` 래퍼 를 사용해야 한다. 그렇다고 모든 변수를 volatile로 표시하기에는 캐시간 데이터를 옮기는 작업이 비싼 작업이기 때문이다.

정리하자면

- 더이상 진정한 의미의 공유메모리는 존재하지 않는다. CPU 코어가 데이터를 캐시라인간에 전송하는 과정은 컴퓨터들이 네트워크 상에서 데이터를 전달하는 것과 마찬가지다. 이제는 메시지를 전송하는 것이 CPU간이든 네트워크 사이에서든 일반적인 표준이다.
- 공유변수라고 표시하거나 원자 데이터 구조를 사용해서 메시지를 전송하는 형태를 숨기능 방식보다 동시성의 엔티티들 간에 명시적으로 메시지를 통해서 데이터나 이벤트를 전파하는 방법이 통제 가능하면서도 근본적인 해결방법이다.



### 콜스택에 대한 착각

콜스택은 다중 CPU시스템이 드물었던, 동시성 프로그래밍이 중요하지 않던 시절의 산물이다. 콜 스택은 여러 스레드들 사이에 걸칠 수 없기 때문에 비동기 콜 체인 모델링할 수 없다.

문제는 스레드가 백그라운드로 태스크를 위임할 때인데, 태스크를 위임한다는 것은 실제로는 다른 스레드가 그 태스크를 실행하도록 위임한다는 뜻이다. 이 과정은 단순한 메서드/함수 호출이 될 수 없다. 호출이란 엄연히 다른 스레드의 로컬 영역이기 때문이다. 일반적인 태스크를 위임하는 형태를 살펴 보면 호출자(Caller)는 객체를 메모리의 특정 위치에 두고 스레드(Callee)가 사용할 수 있도록 공유하면 워커 스레드는 나중에 이벤트 루프 내에서 이 값을 가져와서 사용하는 형태이다. 이 구조를 취함으로써 호출자 스레드는 다른 일을 할 수 있다.

여기서 문제는 호출자(Caller)가 태스크가 완료되었는지 알기 힘들다는 것이다. 더 심각한 문제는 태스크와 예외와 함께 실패한 경우이다. 이 예외는 호출자에게 전달되지 않을 것이고 호출자는 예외를 처리할 수 없게 된다.

이런 상황은 스레드 기반의 워커에 버그가 있는 겨웅에 더 악화되어 복구 불가능한 상황까지 발생시킬 수 있다.

정리하자면

- 현재 시스템 상에서 의미있는 동시성과 성능을 도출시키려면 블로킹이 없는 효율적인 방식으로 스레드에게 태스크를 위임해야 한다. 태스크 위임 방식의 동시성은 (네트워크/분산 컴퓨팅에서 더욱 중요하게) 콜 스택 기반의 에러 처리는 세분화되어 새로운 명시적인 에러 시그널링 방식이 필요하다.
- 태스크 위임의 동시성 시스템은 서비스 실패를 처리해야 하며 실패에서 복구할 근본적인 방법이 필요하다. 이러한 서비스의 클라이언트는 재시작 중에 태스크/메시지를 유실할 수 있다는 것을 알고 있어야 한다. 유실이 발생하지 않더라도 지연이 발생할 수 있으며 이런 이유로 동시성 시스템은 네트워크/분산 시스템과 마찬가지로 타임아웃과 같은 형태의 응답에 대한 기한을 정할 수 있는 체계가 필요하다



## 분산시스템과 액터 모델

액터를 사용한다는 것은

- 락에 의지하지 않고 캡슐화를 강화한다.
- 시그널에 반응하여 형태를 변경하고 서로 시그널을 보내는 협조적인 엔티티 모델을 사용하도록 어플리케이션을 진화시킨다.
- 현실 세계의 관점과 맞지 않는 실행 구조에 대해 걱정하지 않아도 된다.

### 락과 블록킹 없는 메시지 전송

엑터들은 메시지를 호출하지 않고 대신 서로 간에 메시지를 보낸다. 메시지 전송은 발신자가 수신자에게 실행 스레드를 전달하지 않는다. 액터는 블록킹 없이 메시지를 계속 보낼 수 있다. 따라서 액터는 같은 시간에 더 많은 일을 할 수 있다.

메서드는 객체를 리턴할 때 실행 스레드의 제어권도 반환한다. 이런 점에서 액터는 객체와 비슷하게 행동한다. 메시지를 수신하면 현재의 메시지를 처리한 후 실행 권한을 반환한다.

메시지 전송과 메서드 호출의 중요한 차이점은 메시지에는 반환 값이 없다는 것이다. 메시지를 보냄으로써 액터는 해야할 일을 다른 액터로 위임하는 것이다. 콜 스택에 대한 착각에서 살펴봤듯이 만약 액터가 반환 값을 기다린다면 발신자 액터는 블로킹되거나 다른 액터의 작업을 같은 스레드에서 실행해야만 한다. 그러므로 액터모델에서는 메시지를 수신한 액터가 처리 결과를 응답 메시지에 담아서 전송하는 방법을 사용한다.