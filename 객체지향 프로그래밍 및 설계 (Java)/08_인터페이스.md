## 인터페이스

- 컴퓨터 분야에서 인터페이스란 매우 다양한 것을 의미
- 함수의 구현이 아닌 함수의 선언을 의미
- 함수 시그내처를 인터페이스라고 부르기도 한다
  - 함수 선언 == 함수 시그내처 == 인터페이스



![interface](./images/08_1.png)

**OO에서는 순수 추상 클래스를 인터페이스라고 한다**

- Java, C#등은 이 특별한 클래스를 위해 interface란 키워드를 지원한다
- C++은 별도의 키워드가 없어 추상 클래스를 사용해야 한다





#### 인터페이스는 특수한 형태의 클래스다

- 어떤 상태도 없음
- 동작의 구현도 없음
- 동작의 시그내처만 있음
- 이런 특징 때문에 클래스와는 약간 다른 규칙을 따른다



### Java에서의 인터페이스의 특징

- 상속받은 인터페이스의 추상 메서드를 구현하지 않으면 컴파일 오류 발생
  - 추상 클래스 상속과 전혀 다르지 않다
- 미구현으로 인한 컴파일 오류는 실수를 방지
  - 메서드 이름 오타 or 부모클래스의 메서드 이름만 바꾸고 자식 클래스는 손대지 않는 경우
-  Java에서는 `@Override`라는 어노테이션을 제공한다
  - 이 어노테이션을 메서드 위에 사용하면 상속받은 메서드를 구현하겠다는 의미
  - 만약 부모 클래스에 같은 이름의 메서드가 없으면 오류 발생
- 인터페이스는 public 메서드만 가능
  - 누구라도 보고 명령할 수 있는 동작
- 인터페이스는 다중 상속이 가능 (클래스 다중상속은 불가능)
  - 메서드가 중복되더라도 오버라이딩되지 않기 때문에 실체가 겹칠 위험이 없음
    - 아무리 복잡하게 상속 구조를 해도 구현은 하나 뿐
  - 인터페이스는 두 실체가 중복되어도 상속받은 클래스가 구현만 제공하면 됨
  - 단 반환형만 다르면 컴파일 오류가 난다
    - 두 함수를 다 구현할 방법이 없기 때문에
    - 반환형만 다른 경우는 올바른 함수 오버로딩이 아님
  - **인터페이스는 다중 상속의 해결법**
- **함수 포인터처럼 사용하는 인터페이스**



> 어노테이션
>
> - 프로그램에 대한 메타 데이터를 제공
>   - 프로그램의 일부가 아니어서 코드 실행에는 아무 영향을 미치지 않음
> - 어노테이션의 용도
>   - 컴파일러에게 정보를 제공 (`@Deprecated`, `@Override`)
>     - `@Deprecated` : 더 이상 지원을 안 할 함수. 만약 이 함수를 사용시 컴파일러가 경고함
>   - 컴파일 또는 배포 중에 어노테이션을 기반으로 어떤 처리를 할 수 있음
>     - 문서 제작 등..
>   - 실행 중에서도 어노테이션을 기반으로 어떤 처리를 할 수 있음



### Object.clone()

**Java의 특징**

- Java에서 클래스형은 다 참조형 (C의 포인터)
- 단순 대입으로는 복사가 일어나지 않는다
- 여전히 같은 주소를 가리키는 포인터 개념

#### Object.clone()메서드

- 복사를 원할 경우 clone() 메서드를 구현하면 됨
- 이때 `Clonalbe` 인터페이스를 상속 후 구현
- Cloneable 인터페이스를 상속받지 않고 오버라이딩하면 `CloneNotSupportedException` 예외 발생



#### 복제를 하는 올바른 방법

- Cloneable 메서드를 상속받고, `clone()`메서드에서`super.clone()`을 호출하는 것
- 각 클래스마다 clone()의 의미는 다를 수 있음
  - Object는 실제 자식 개체의 개체를 만들고 모든 멤버를 대입해서 반환 (얕은복사)
- `clone()` 사용 시 `Object`를 반환하기 때문에 실제 사용시에는 캐스팅이 필요하다