## 인터페이스

- 컴퓨터 분야에서 인터페이스란 매우 다양한 것을 의미
- 함수의 구현이 아닌 함수의 선언을 의미
- 함수 시그내처를 인터페이스라고 부르기도 한다
  - 함수 선언 == 함수 시그내처 == 인터페이스



![interface](./images/08_1.png)

**OO에서는 순수 추상 클래스를 인터페이스라고 한다**

- Java, C#등은 이 특별한 클래스를 위해 interface란 키워드를 지원한다
- C++은 별도의 키워드가 없어 추상 클래스를 사용해야 한다





#### 인터페이스는 특수한 형태의 클래스다

- 어떤 상태도 없음
- 동작의 구현도 없음
- 동작의 시그내처만 있음
- 이런 특징 때문에 클래스와는 약간 다른 규칙을 따른다



### Java에서의 인터페이스의 특징

- 상속받은 인터페이스의 추상 메서드를 구현하지 않으면 컴파일 오류 발생
  - 추상 클래스 상속과 전혀 다르지 않다
- 미구현으로 인한 컴파일 오류는 실수를 방지
  - 메서드 이름 오타 or 부모클래스의 메서드 이름만 바꾸고 자식 클래스는 손대지 않는 경우
-  Java에서는 `@Override`라는 어노테이션을 제공한다
  - 이 어노테이션을 메서드 위에 사용하면 상속받은 메서드를 구현하겠다는 의미
  - 만약 부모 클래스에 같은 이름의 메서드가 없으면 오류 발생
- 인터페이스는 public 메서드만 가능
  - 누구라도 보고 명령할 수 있는 동작
- 인터페이스는 다중 상속이 가능 (클래스 다중상속은 불가능)
  - 메서드가 중복되더라도 오버라이딩되지 않기 때문에 실체가 겹칠 위험이 없음
    - 아무리 복잡하게 상속 구조를 해도 구현은 하나 뿐
  - 인터페이스는 두 실체가 중복되어도 상속받은 클래스가 구현만 제공하면 됨
  - 단 반환형만 다르면 컴파일 오류가 난다
    - 두 함수를 다 구현할 방법이 없기 때문에
    - 반환형만 다른 경우는 올바른 함수 오버로딩이 아님
  - **인터페이스는 다중 상속의 해결법**
- **함수 포인터처럼 사용하는 인터페이스**



> 어노테이션
>
> - 프로그램에 대한 메타 데이터를 제공
>   - 프로그램의 일부가 아니어서 코드 실행에는 아무 영향을 미치지 않음
> - 어노테이션의 용도
>   - 컴파일러에게 정보를 제공 (`@Deprecated`, `@Override`)
>     - `@Deprecated` : 더 이상 지원을 안 할 함수. 만약 이 함수를 사용시 컴파일러가 경고함
>   - 컴파일 또는 배포 중에 어노테이션을 기반으로 어떤 처리를 할 수 있음
>     - 문서 제작 등..
>   - 실행 중에서도 어노테이션을 기반으로 어떤 처리를 할 수 있음





### 구체클래스 vs 인터페이스

| 구체 클래스                      | 인터페이스                        |
| -------------------------------- | --------------------------------- |
| 상태와 동작을 모두 포함          | 동작에 대한 설명만 포함           |
| 동작에 다양한 접근권한 부여 가능 | 모든 동작은 public                |
| 구체클래스로부터 개체 생성 가능  | 인터페이스로부터 개체 생성 불가능 |
| 다중 상속의 부모가 될 수 없음    | 다중 상속의 부모가 될 수 있음     |

### Object.clone()

**Java의 특징**

- Java에서 클래스형은 다 참조형 (C의 포인터)
- 단순 대입으로는 복사가 일어나지 않는다
- 여전히 같은 주소를 가리키는 포인터 개념

#### Object.clone()메서드

- 복사를 원할 경우 clone() 메서드를 구현하면 됨
- 이때 `Clonalbe` 인터페이스를 상속 후 구현
- Cloneable 인터페이스를 상속받지 않고 오버라이딩하면 `CloneNotSupportedException` 예외 발생



#### 복제를 하는 올바른 방법

- Cloneable 메서드를 상속받고, `clone()`메서드에서`super.clone()`을 호출하는 것
- 각 클래스마다 clone()의 의미는 다를 수 있음
  - Object는 실제 자식 개체의 개체를 만들고 모든 멤버를 대입해서 반환 (얕은복사)
- `clone()` 사용 시 `Object`를 반환하기 때문에 실제 사용시에는 캐스팅이 필요하다

 

## 의존선과 결합도

### 의존성

- 소프트웨어 모듈 A가 제대로 작동하려면 다른 모듈 B가 필요한경우
  - OO에서는 모듈 == 클래스라고 생각
- 클래스 A가 클래스 B에 의존한다는 의미
  - B가 없으면 A는 작동하지 못함
  - A가 없어도 B는 작동



### 의존성이 있어야 좋은 설계

- 각 클래스의 목적이 뚜렷하다는 의미
- 캡슐화가 잘 되어있다는 의미
- 클래스를 재사용할 수 있다는 의미
  - 함수 재사용성과 마찬가지
  - 의존성을 완전히 없애려면 프로그램 전체를 함수 하나에 작성하면 됨...

**그럼에도 의존성이 나쁘다고 생각하는 의미는?**

1. 결합도란 용어와 혼용해서 사용해서
2. 결합도라는 용어도 너무 생략해서 잘못 사용해서



### 결합도

- 종종 커플링이(coupling)라고 음차해서 사용
- 원래 의미는 두 소프트웨어 모듈 간에 상호 의존성 정도
  - 클래스 A가 클래스 B에 의존
  - 클래스 B가 클래스 A에 의존
  - A와 B중 하나도 독자 생존이 불가능
- 여러 가지 종류의 결합도가 존재

![결합도](./images/08_2.png)



### OO에서 흔이 논하는 결합도

**A가 B에 의존하는 상황에서 B를 변경할 때 프로그램이 잘 작동하는가?**

- A의 내부를 변경하지 않아도 제대로 동작
  - A가 B에 의존하나 그 정도가 높지 않음
  - 즉, 결합도가 낮음

- A의 내부를 변경해야만 제대로 동작한다
  - A가 B에 의존하는 정도가 높음
  - 즉, 결합도가 높음

**즉, B코드 변경 시 A코드도 변경해야 하면 결합도가 높은 것**



## 디커플링

- 결합도를 낮추는 작업
- 유연성, 재사용성을 높임
  - 미래의 변화에 대비되어 있다는 의미

### 디커플링의 단점

- 직관적이지 못함
- 내부를 알아야 좋은 경우도 있다

> 디커플링의 좋은 예 : 이클립스 (IDE)의 API
>
> 이클립스는 나중에 API가 바뀌는 일을 방지하기 위해 꼼꼼히 설계하였다. 그러나 전혀 빠귀지 않는 API는 발전도 없어서 변화가 필수적인데 API가 올라가도 변화를 적게 유지하기 위해 아래의 두 키워드에 의미를 부여하고 약속하였다.
>
> - interface : 절대로 안 바뀌는 것
> - class : 언제든 바뀌는 것
>
> 즉, **한 번 공개한 인터페이스는 절대 바뀌면 안된다** 라는 원칙을 세웠다. 그러나 인터페이스도 발전을 위해서 변화가 필요했고 나름의 해결법으로 이전버전과 호환되는 새로운 인터페이스를 만들었고, 인터페이스의 약속을 지키고 새로운 버전으로 업그레이드 할 수 있는 옵션도 제공했다.
>
> 단, 이 원칙의 경우 단점이 있어서 조심해야 한다.
>
> - 인터페이스가 깔끔하게 유지되지 않음
> - 변화가 느리다
>   - 요즘은 발전 속도를 중시하는 경향이 있음
> - 설계에 투자를 많이 해야 하기 때문에 비용의 문제 발생
> - 이러한 프로젝트가 흔하지는 않으며, 이 정도로 범용적인 라이브러리도 많지 않음
>
> 요즘은 버전 업 속도가 빨라졌고, 이를 위해 일반적으로 여러 버전을 지원하곤 한다.
>
> - 새로운 기능이나 breaking 변화는 새 버전에만 추가
> - 버전 별로 지원 기간을 명시
>   - 지원기간 동안 업데이트를 모든 버전에 적용
>   - 지원기간이 지나면 다음 버전으로 옮겨야 함
> - 라이브러리 제작자는 마이그레이션 가이드를 제공. 특히 지원기간이 긴 (LTS) 버전을 가끔 제공
>   - 일반 버전 : 짧게만 지원 (빠른 변화가 필요할 때)
>   -  LTS 버전 : 그나마 오랫동안 그 버전을 지원

## 올바른 인터페이스

### 일단 주관성이 적은 방향으로 이해하자

- 그냥 주류 언어와 그 용도에 따라 interface를 이해할 것. 그리고 이 외의 주관적인 의견은 그 장점이 확실히 보일 때 받아들일 것

**협업 시 가장 중요한 목표는 실수 예방**

- 소프트웨어 개발은 협업환경
- 모두가 직관적으로 이해할 수 있는 방법은 실수를 줄임
  - 주관성이 그나마 적음
  - 많은 사람들이 직관적으로 이해할 수 있는 것이 OO의 캡슐화

- 다형성 포인터 재귀함수등이 이해하기 어려운 이유가 바로 직관성이 적기 때문이다
  - 한 단계 건너 뛰어서 생각해야 하기 때문
  - 직관성이 줄어들고 추상적
- 따라서 기본적으로는 추상화를 안 하는게 실수가 적다



