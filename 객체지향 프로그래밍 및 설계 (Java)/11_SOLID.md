## SOLID원칙

- 다섯가지 원칙의 약자
  - Single-responsibility principle : 단일 책임 원칙 (SRP)
  - Open-closed principle : 개방-폐쇠 원칙 (OCP)
  - Liskov substitution principle : 리스코프 치환 원칙 (LSP)
  - Interface segregation principle : 인터페이스 분리 원칙 (ISP)
  - Dependency inversion principle : 의존 역전 원칙 (DIP)

- 이해하기 쉽고, 유연하고, 유지보가 쉽게 만들기 위해 나온 원칙

- 사실 원칙도 규칙도 아닌 방향성을 제시할 뿐이라서 원칙이라고 부르기는 애매하다
  - 알아두면 좋은 정도의 주관적인 내용
  - 모든 코드를 SOLID에 맞춰 작성하면 그 자체로 유지보수가 힘든 코드가 되기 때문에 주의해야한다.
  - 디자인 패턴과 마찬가지로 지양되어가는 추세



### SOLID가 도움될 만한 곳

- SOLID는 디커플링을 중요하게 여기니 대규모 프로젝트일수록 유용하다
  - 따라서 모든 프로젝트에 적용할 수 있다고 생각하지 않아야 한다
- 직접적/구체적인게 더 이해하기 쉽다는 사실을 잊지 말아야 한다
  - 시작은 직접적/구체적으로 설계하고 규모가 커지면서 유연셩이 필요해지면 그때부터 바꿔갈 대 도움이 될 정신이다.



## 단일 책임

- Only do one thing. One reason to change
  - 클래스는 오직 한 가지 일만 해야 한다
  - 클래스를 바꿀 상황이 생긴다면 바꾸려는 이유가 하나여야 한다
- 클래스의 존재 이유는 하나여야만 한다는 의미



### Only do one thing

- 한 함수에서 너무 많은 일을 하지 말라는 말과 비슷
- 그냥 클래스에서 너무 많은 일을 하지 말라는 얘기
- 기본적으로는 좋은 이야기이자 좋은 정신

**단일 책임 개념의 의의**

- 코드를 보는 대부분의 사람이 이해할 수 있는 크기로 클래스를 만들자
  - 최대한 간단하게 만들되, 너무 간단하진 않게 만들어야 한다.
  - 물론 주관적



### One reason to change

- 클래스를 바꿀 상황이 생긴다면 바꾸려는 이유가 하나여야 한다
  - 각 클래스의 책임을 분명하게 정의하자. 그래야 오류상황에서 대응하기 쉽다.

- 비판
  - 그 바꿀 이유가 뭔지 미리 알 수가 없다
    - 만약 미리 알았다면 바꿀 필요가 없도록 클래스를 만들었을 것이다
    - 즉, 바꾸려는 이유가 몇개가 될지 예측하기 어렵다



## 개방-폐쇠

- Open for extension. Closed for modification
  - 확장은 가능하게, 그러나 수정은 불가능하게
- 클래스 내부 수정 없이 동작을 확장할 수 있어야 한다는 의미
  - 상속, 다형성이 좋은 예시



## 리스코프 치환

- '자식이 부모의 동작을 상속받는다면, 부모의 동작은 아무 문제 없이 작동해야 한다'는 원칙
  - 즉 부모가 할 수 있었던 일은 자식도 할 수 있어야 함
  - 지키지 않을 경우 호출자 코드가 어느 순간 동작하지 않을 수 있다
    - 선언된 자료형만 보면 실제 개체가 뭔지 모르기 때문에

