## 클래스와 개체

### OOP에서의 클래스

- 새로운 개체를 만들 때 사용하는 명세서
- 개체는 반드시 클래스로부터 만들어줘야 함



## 포인터

- 자바에서는 기본 자료형을 제외하면 모두 포인터 형 (그리고 그것을 참조형이라고 부른다)
- 자바에 포인터가 없다는 것은 거짓말이다. 자바에서는 모든 것이 포인터라고 해도 될 정도이다.
  - 다만 포인터 연산은 불가능하다
  - 기본 자료형은 예외이다.
  - Java에서는 `.` 연산자는 클래스에서만 사용 가능하므로, 이 연산자를 사용하면 무조건 내용이 바뀔 수 있다는 점을 생각해야 한다.

## Java에서 개체 생성 시 멤버 데이터의 초기화

- 모든 값을 0에 준하는 값으로 초기화해준다.
  - `int` 는 0
  - `float` 는 0.0
  - 참조형은 null

- C는 성능이 제일 중요해서 초기화해주지 않지만, Java는 실수 방지가 중요하기 때문에 모든 값을 초기화해준다.

## 메모리 관리

### 가비지 컬렉션

- Java에는 가비지 컬렉션 (garbage collection, GC)기능을 지원
  - JVM에 내장된 가비지 컬렉터가 알아서 가비지(쓰레기)를 치워줌
  - 가비지란? 더 이상 사용되지 않는 개체 (즉, 힙 메모리)
  - 프로그래머가 직접 메모리를 해제하지 않는다
  - C#도 가비지 컬렉션을 지원한다
- 매니지드 언어는 보통 자동으로 메모리를 관리해준다.

#### 가비지 컬렉션의 단점

- 가비지 컬렉터가 메모리를 수집하는 시점을 알 수 없음
- 모든 개체의 사용 여부를 판단하는게 그리 빠른 연산이 아님
  - 이런 이유로 자원이 한정적인 시스템에는 적합하지 않음
    - 메모리 해제를 프로그래머가 직접 할 경우 이런 문제가 없음
  - 자동 메모리 관리 하에서발생하는 메모리 누수도 존재
    - 즉, 자동 메모리 관리도 메모리 누수에서 100% 자유로울 수 없음



## getter/setter

#### 함수를 통한 데이터 접근의 객관적인 장범

1. 멤버 변수를 저장하지 않고 필요할 때마다 getter에서 계산 가능
2. setter에서 추가적인 로직을 실행할 수 있음
3. 상속을 통한 다형성 구현 가능



## 캡슐화

1. 개체의 데이터와 동작을 하나로 묶음
2. 내부의 데이터를 외부로부터 보호

- 사용자가 클래스 속을 알 필요가 없음
  - 사용자가 함수 속을 알 필요가 없는 것과 마찬가지
  - 이 개념은 추강화로 이어짐
- 함수를 분리할 때 적용했던 원칙을 클래스에서도 적용할 것
  - 중복된 코드가 있다면 `private` 메서드로



## 추상화

#### 추상 자료형쪽 관점

- 사용자는 클래스를 자료형으로 사용할 수 있음
- 그 클래스 안에 들어있는 멤버 변수가 정확히 뭔지 몰라도 됨
- 그냥 클래스로부터 개체 생성 가능

#### 절차적 데이터 추상화쪽 관점

- 데이터를 직접 조작하는 대신 메서드를 호출
- 이게 OOP라는 용어를 처음 주장했다는 소수설의 관점과 유사