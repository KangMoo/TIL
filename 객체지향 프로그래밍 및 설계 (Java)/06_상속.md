## 상속

- 거의 모든 사람이 OOP 핵심이라 여기는 특성
  - 초창기 OO에서 가장 중요한 특성이라 여겼음
  - 재사용성이 궁극의 목적이라 신봉하던 시대
  - 현재에도 상속을 지원하지 않으면 OO 언어라고 안 보는게 보통이다
- OOP의 또 다른 매우 중요한 특성인 **다형성의 기반**



### OOP에서의 상속이란

- 이미 존재하는 클래스를 기반으로 새 클래스를 만드는 방법
  - 새 클래스는 기존 클래스의 동작과 상태를 그대로 물려받음 (유전)
  - 그 외에 새 클래스만의 동작과 상태를 추가 가능 (진화)
  - 물론 새클래스를 상속해서 또 다른 새 클래스를 만들 수 있음

### super 키워드

- super는 현 개체의 부모 부분을 가리킴
- super() 라고 코드를 작성하면 부모의 생성자를 호출
- 멤버 변수나 메서드를 호출할 때도 가능

### 접근제어자 protected
- `protected <자료형> <변수명>;`
- `protected <반환형> <함수명> (<매개변수 목록>) { ... }`
- `protected class <클래스명> { ... }`
- 외부자들은 접근할 수 없음
- 클래스 내부, 같은 패키지에 속한 클래스, 자식 클래스만 접근 가능
- 클래스의 경우 냐포된 클래스에 한 해 붙일 수 있음



### 상속 vs 컴포지션

- 둘 다 재사용성을 위한 방법
- 상속으로 해결할 수 있는 많은 문제를 컴포지션으로도 가능
  - 그 반대도 가능
  - 순전히 기술적인 관점
- 역사적으로 사람들의 선호는 왔다갔다 한다
  - 초창기에는 상속을 과도하게 선호
  - 그 후 무조건 컴포지션이 답이라는 잘못된 조언을 많이 따랐음 (현재진행형)
- OO에서 가장 큰 결정사항 중 하나 : 상속 vs 컴포지션 중 하나를 고르는 것

- 가이드라인

  - 실생활에서 개채들끼리의 관계를 기준으로 선택

    has-a 관계 : 컴포지션

    is-a 관계 : 상속

- 물론 훌륭한 프로그래머들은 필요에 따라 이 규칙을 어긴다.



### 상속과 컴포지션 선택 시 고려할 사항

- 기계상의 차이 때문에 하나를 골라야 할 때 (메모리 상의 차이는 용량보다는 실행 성능에 영향을 미친다)
  - 상속 : 개체 생성 시, **메모리가 하나의 덩어리**다. 개체가 한 번에 캐시 메모리에 들어갈 가능성이 높다.
  - 컴포지션 : 개체 생성 시 **메모리가 여러 덩어리**다. 개체 내 부품 수 만큼 캐시 메모리로 로딩할 가능성이 높다.
  - 즉, 좋은 성능이 필요하다면 상속을 고르는 것이 더 좋다.
- 용도 때문에 상쇽을 고를 수밖에 없을 때
- 관리의 효율성을 고려할 때
- 그 외 일반적인 상황